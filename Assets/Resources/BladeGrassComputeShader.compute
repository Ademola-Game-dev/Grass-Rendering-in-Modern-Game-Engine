// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "Simplex.compute"

struct Blade
{
    float3 position;
    float windOffset;
};

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
AppendStructuredBuffer<Blade> _BladeGrassBuffer;

float3 _CamPosInWorldSpace;
float _DistanceCullingThreshold;
uint _Dimension;
float2 _PlacementOffset;
float3 _InitialPos;
float4x4 _CamClippingMatrix;
float _NearPlaneOffset;
float4 _Time;

Texture2D WindTex;
SamplerState samplerWindTex;

float Clamp(float min, float max, float target)
{
    if (target < min)
    {
        return min;
    }
    else if (target > max)
    {
        return max;
    }
    return target;
}

uint DistanceCulling(float3 worldPos)
{
    // Get the world position of current grass instance
    // Get the world position of main camera
    // Calculate the distance between two positions
    // Cull if distance exeeds the threshold
    
    float d = distance(worldPos, _CamPosInWorldSpace);
    
    if (d <= _DistanceCullingThreshold)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

uint FrustumCulling(float4 clippingPos)
{
    // The size of clipping space is about [-clippingPos.w, clippingPos.w]
    // Only need to check if x y z values are inside the range
    
    bool isOutsideFarNearPlane = clippingPos.z > clippingPos.w || clippingPos.z < -clippingPos.w;
    bool isOutsideLeftRightPlane = clippingPos.x < -clippingPos.w || clippingPos.x > clippingPos.w;
    bool isOutsideBottomTopPlane = clippingPos.y < -clippingPos.w + -_NearPlaneOffset || clippingPos.y > clippingPos.w;

    if (isOutsideFarNearPlane || isOutsideLeftRightPlane || isOutsideBottomTopPlane)
    {
        return 0; // The point is outside the frustum
    }
    else
    {
        return 1; // The point is inside the frustum
    }
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _Dimension || id.y >= _Dimension)
    {
        return;
    }
    
    float randomOffset = Clamp(0.0, 0.99, (snoise(id) * 0.3));

    float spawnX = (id.x / _PlacementOffset.x) + randomOffset;
    float spawnZ = (id.y / _PlacementOffset.y) + randomOffset;
    
    // Correct each position
    float3 finalPos = float3(spawnX, 0.05f, spawnZ);
    float3 revisedPos = _InitialPos + finalPos;
    
    uint distanceCulling = DistanceCulling(revisedPos);
    
    // Calculate for frustum culling
    float4 clippingSpacePos = mul(_CamClippingMatrix, float4(revisedPos, 1.0));
    uint frustumCulling = FrustumCulling(clippingSpacePos);

    if (distanceCulling == 1 && frustumCulling == 1)
    {
        // Calculate wind
        float2 sampleUV = float2(revisedPos.x, revisedPos.z);
        sampleUV += _Time.y * 0.12f;
        
        float windOffset = WindTex.SampleLevel(samplerWindTex, sampleUV, 0).x;
        
        Blade blade;
        blade.position = revisedPos;
        blade.windOffset = windOffset;
        
        _BladeGrassBuffer.Append(blade);
    }
}
